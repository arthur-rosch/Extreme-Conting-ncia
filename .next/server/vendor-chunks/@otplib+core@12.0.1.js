"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@otplib+core@12.0.1";
exports.ids = ["vendor-chunks/@otplib+core@12.0.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@otplib+core@12.0.1/node_modules/@otplib/core/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@otplib+core@12.0.1/node_modules/@otplib/core/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @otplib/core\n *\n * @author Gerald Yeo <contact@fusedthought.com>\n * @version: 12.0.1\n * @license: MIT\n **/\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction objectValues(value) {\n  return Object.keys(value).map(key => value[key]);\n}\n(function (HashAlgorithms) {\n  HashAlgorithms[\"SHA1\"] = \"sha1\";\n  HashAlgorithms[\"SHA256\"] = \"sha256\";\n  HashAlgorithms[\"SHA512\"] = \"sha512\";\n})(exports.HashAlgorithms || (exports.HashAlgorithms = {}));\nconst HASH_ALGORITHMS = objectValues(exports.HashAlgorithms);\n(function (KeyEncodings) {\n  KeyEncodings[\"ASCII\"] = \"ascii\";\n  KeyEncodings[\"BASE64\"] = \"base64\";\n  KeyEncodings[\"HEX\"] = \"hex\";\n  KeyEncodings[\"LATIN1\"] = \"latin1\";\n  KeyEncodings[\"UTF8\"] = \"utf8\";\n})(exports.KeyEncodings || (exports.KeyEncodings = {}));\nconst KEY_ENCODINGS = objectValues(exports.KeyEncodings);\n(function (Strategy) {\n  Strategy[\"HOTP\"] = \"hotp\";\n  Strategy[\"TOTP\"] = \"totp\";\n})(exports.Strategy || (exports.Strategy = {}));\nconst STRATEGY = objectValues(exports.Strategy);\nconst createDigestPlaceholder = () => {\n  throw new Error('Please provide an options.createDigest implementation.');\n};\nfunction isTokenValid(value) {\n  return /^(\\d+)$/.test(value);\n}\nfunction padStart(value, maxLength, fillString) {\n  if (value.length >= maxLength) {\n    return value;\n  }\n  const padding = Array(maxLength + 1).join(fillString);\n  return `${padding}${value}`.slice(-1 * maxLength);\n}\nfunction keyuri(options) {\n  const tmpl = `otpauth://${options.type}/{labelPrefix}:{accountName}?secret={secret}{query}`;\n  const params = [];\n  if (STRATEGY.indexOf(options.type) < 0) {\n    throw new Error(`Expecting options.type to be one of ${STRATEGY.join(', ')}. Received ${options.type}.`);\n  }\n  if (options.type === 'hotp') {\n    if (options.counter == null || typeof options.counter !== 'number') {\n      throw new Error('Expecting options.counter to be a number when options.type is \"hotp\".');\n    }\n    params.push(`&counter=${options.counter}`);\n  }\n  if (options.type === 'totp' && options.step) {\n    params.push(`&period=${options.step}`);\n  }\n  if (options.digits) {\n    params.push(`&digits=${options.digits}`);\n  }\n  if (options.algorithm) {\n    params.push(`&algorithm=${options.algorithm.toUpperCase()}`);\n  }\n  if (options.issuer) {\n    params.push(`&issuer=${encodeURIComponent(options.issuer)}`);\n  }\n  return tmpl.replace('{labelPrefix}', encodeURIComponent(options.issuer || options.accountName)).replace('{accountName}', encodeURIComponent(options.accountName)).replace('{secret}', options.secret).replace('{query}', params.join(''));\n}\nclass OTP {\n  constructor(defaultOptions = {}) {\n    this._defaultOptions = Object.freeze({ ...defaultOptions\n    });\n    this._options = Object.freeze({});\n  }\n  create(defaultOptions = {}) {\n    return new OTP(defaultOptions);\n  }\n  clone(defaultOptions = {}) {\n    const instance = this.create({ ...this._defaultOptions,\n      ...defaultOptions\n    });\n    instance.options = this._options;\n    return instance;\n  }\n  get options() {\n    return Object.freeze({ ...this._defaultOptions,\n      ...this._options\n    });\n  }\n  set options(options) {\n    this._options = Object.freeze({ ...this._options,\n      ...options\n    });\n  }\n  allOptions() {\n    return this.options;\n  }\n  resetOptions() {\n    this._options = Object.freeze({});\n  }\n}\n\nfunction hotpOptionsValidator(options) {\n  if (typeof options.createDigest !== 'function') {\n    throw new Error('Expecting options.createDigest to be a function.');\n  }\n  if (typeof options.createHmacKey !== 'function') {\n    throw new Error('Expecting options.createHmacKey to be a function.');\n  }\n  if (typeof options.digits !== 'number') {\n    throw new Error('Expecting options.digits to be a number.');\n  }\n  if (!options.algorithm || HASH_ALGORITHMS.indexOf(options.algorithm) < 0) {\n    throw new Error(`Expecting options.algorithm to be one of ${HASH_ALGORITHMS.join(', ')}. Received ${options.algorithm}.`);\n  }\n  if (!options.encoding || KEY_ENCODINGS.indexOf(options.encoding) < 0) {\n    throw new Error(`Expecting options.encoding to be one of ${KEY_ENCODINGS.join(', ')}. Received ${options.encoding}.`);\n  }\n}\nconst hotpCreateHmacKey = (algorithm, secret, encoding) => {\n  return Buffer.from(secret, encoding).toString('hex');\n};\nfunction hotpDefaultOptions() {\n  const options = {\n    algorithm: exports.HashAlgorithms.SHA1,\n    createHmacKey: hotpCreateHmacKey,\n    createDigest: createDigestPlaceholder,\n    digits: 6,\n    encoding: exports.KeyEncodings.ASCII\n  };\n  return options;\n}\nfunction hotpOptions(opt) {\n  const options = { ...hotpDefaultOptions(),\n    ...opt\n  };\n  hotpOptionsValidator(options);\n  return Object.freeze(options);\n}\nfunction hotpCounter(counter) {\n  const hexCounter = counter.toString(16);\n  return padStart(hexCounter, 16, '0');\n}\nfunction hotpDigestToToken(hexDigest, digits) {\n  const digest = Buffer.from(hexDigest, 'hex');\n  const offset = digest[digest.length - 1] & 0xf;\n  const binary = (digest[offset] & 0x7f) << 24 | (digest[offset + 1] & 0xff) << 16 | (digest[offset + 2] & 0xff) << 8 | digest[offset + 3] & 0xff;\n  const token = binary % Math.pow(10, digits);\n  return padStart(String(token), digits, '0');\n}\nfunction hotpDigest(secret, counter, options) {\n  const hexCounter = hotpCounter(counter);\n  const hmacKey = options.createHmacKey(options.algorithm, secret, options.encoding);\n  return options.createDigest(options.algorithm, hmacKey, hexCounter);\n}\nfunction hotpToken(secret, counter, options) {\n  const hexDigest = options.digest || hotpDigest(secret, counter, options);\n  return hotpDigestToToken(hexDigest, options.digits);\n}\nfunction hotpCheck(token, secret, counter, options) {\n  if (!isTokenValid(token)) {\n    return false;\n  }\n  const systemToken = hotpToken(secret, counter, options);\n  return token === systemToken;\n}\nfunction hotpKeyuri(accountName, issuer, secret, counter, options) {\n  return keyuri({\n    algorithm: options.algorithm,\n    digits: options.digits,\n    type: exports.Strategy.HOTP,\n    accountName,\n    counter,\n    issuer,\n    secret\n  });\n}\nclass HOTP extends OTP {\n  create(defaultOptions = {}) {\n    return new HOTP(defaultOptions);\n  }\n  allOptions() {\n    return hotpOptions(this.options);\n  }\n  generate(secret, counter) {\n    return hotpToken(secret, counter, this.allOptions());\n  }\n  check(token, secret, counter) {\n    return hotpCheck(token, secret, counter, this.allOptions());\n  }\n  verify(opts) {\n    if (typeof opts !== 'object') {\n      throw new Error('Expecting argument 0 of verify to be an object');\n    }\n    return this.check(opts.token, opts.secret, opts.counter);\n  }\n  keyuri(accountName, issuer, secret, counter) {\n    return hotpKeyuri(accountName, issuer, secret, counter, this.allOptions());\n  }\n}\n\nfunction parseWindowBounds(win) {\n  if (typeof win === 'number') {\n    return [Math.abs(win), Math.abs(win)];\n  }\n  if (Array.isArray(win)) {\n    const [past, future] = win;\n    if (typeof past === 'number' && typeof future === 'number') {\n      return [Math.abs(past), Math.abs(future)];\n    }\n  }\n  throw new Error('Expecting options.window to be an number or [number, number].');\n}\nfunction totpOptionsValidator(options) {\n  hotpOptionsValidator(options);\n  parseWindowBounds(options.window);\n  if (typeof options.epoch !== 'number') {\n    throw new Error('Expecting options.epoch to be a number.');\n  }\n  if (typeof options.step !== 'number') {\n    throw new Error('Expecting options.step to be a number.');\n  }\n}\nconst totpPadSecret = (secret, encoding, minLength) => {\n  const currentLength = secret.length;\n  const hexSecret = Buffer.from(secret, encoding).toString('hex');\n  if (currentLength < minLength) {\n    const newSecret = new Array(minLength - currentLength + 1).join(hexSecret);\n    return Buffer.from(newSecret, 'hex').slice(0, minLength).toString('hex');\n  }\n  return hexSecret;\n};\nconst totpCreateHmacKey = (algorithm, secret, encoding) => {\n  switch (algorithm) {\n    case exports.HashAlgorithms.SHA1:\n      return totpPadSecret(secret, encoding, 20);\n    case exports.HashAlgorithms.SHA256:\n      return totpPadSecret(secret, encoding, 32);\n    case exports.HashAlgorithms.SHA512:\n      return totpPadSecret(secret, encoding, 64);\n    default:\n      throw new Error(`Expecting algorithm to be one of ${HASH_ALGORITHMS.join(', ')}. Received ${algorithm}.`);\n  }\n};\nfunction totpDefaultOptions() {\n  const options = {\n    algorithm: exports.HashAlgorithms.SHA1,\n    createDigest: createDigestPlaceholder,\n    createHmacKey: totpCreateHmacKey,\n    digits: 6,\n    encoding: exports.KeyEncodings.ASCII,\n    epoch: Date.now(),\n    step: 30,\n    window: 0\n  };\n  return options;\n}\nfunction totpOptions(opt) {\n  const options = { ...totpDefaultOptions(),\n    ...opt\n  };\n  totpOptionsValidator(options);\n  return Object.freeze(options);\n}\nfunction totpCounter(epoch, step) {\n  return Math.floor(epoch / step / 1000);\n}\nfunction totpToken(secret, options) {\n  const counter = totpCounter(options.epoch, options.step);\n  return hotpToken(secret, counter, options);\n}\nfunction totpEpochsInWindow(epoch, direction, deltaPerEpoch, numOfEpoches) {\n  const result = [];\n  if (numOfEpoches === 0) {\n    return result;\n  }\n  for (let i = 1; i <= numOfEpoches; i++) {\n    const delta = direction * i * deltaPerEpoch;\n    result.push(epoch + delta);\n  }\n  return result;\n}\nfunction totpEpochAvailable(epoch, step, win) {\n  const bounds = parseWindowBounds(win);\n  const delta = step * 1000;\n  return {\n    current: epoch,\n    past: totpEpochsInWindow(epoch, -1, delta, bounds[0]),\n    future: totpEpochsInWindow(epoch, 1, delta, bounds[1])\n  };\n}\nfunction totpCheck(token, secret, options) {\n  if (!isTokenValid(token)) {\n    return false;\n  }\n  const systemToken = totpToken(secret, options);\n  return token === systemToken;\n}\nfunction totpCheckByEpoch(epochs, token, secret, options) {\n  let position = null;\n  epochs.some((epoch, idx) => {\n    if (totpCheck(token, secret, { ...options,\n      epoch\n    })) {\n      position = idx + 1;\n      return true;\n    }\n    return false;\n  });\n  return position;\n}\nfunction totpCheckWithWindow(token, secret, options) {\n  if (totpCheck(token, secret, options)) {\n    return 0;\n  }\n  const epochs = totpEpochAvailable(options.epoch, options.step, options.window);\n  const backward = totpCheckByEpoch(epochs.past, token, secret, options);\n  if (backward !== null) {\n    return backward * -1;\n  }\n  return totpCheckByEpoch(epochs.future, token, secret, options);\n}\nfunction totpTimeUsed(epoch, step) {\n  return Math.floor(epoch / 1000) % step;\n}\nfunction totpTimeRemaining(epoch, step) {\n  return step - totpTimeUsed(epoch, step);\n}\nfunction totpKeyuri(accountName, issuer, secret, options) {\n  return keyuri({\n    algorithm: options.algorithm,\n    digits: options.digits,\n    step: options.step,\n    type: exports.Strategy.TOTP,\n    accountName,\n    issuer,\n    secret\n  });\n}\nclass TOTP extends HOTP {\n  create(defaultOptions = {}) {\n    return new TOTP(defaultOptions);\n  }\n  allOptions() {\n    return totpOptions(this.options);\n  }\n  generate(secret) {\n    return totpToken(secret, this.allOptions());\n  }\n  checkDelta(token, secret) {\n    return totpCheckWithWindow(token, secret, this.allOptions());\n  }\n  check(token, secret) {\n    const delta = this.checkDelta(token, secret);\n    return typeof delta === 'number';\n  }\n  verify(opts) {\n    if (typeof opts !== 'object') {\n      throw new Error('Expecting argument 0 of verify to be an object');\n    }\n    return this.check(opts.token, opts.secret);\n  }\n  timeRemaining() {\n    const options = this.allOptions();\n    return totpTimeRemaining(options.epoch, options.step);\n  }\n  timeUsed() {\n    const options = this.allOptions();\n    return totpTimeUsed(options.epoch, options.step);\n  }\n  keyuri(accountName, issuer, secret) {\n    return totpKeyuri(accountName, issuer, secret, this.allOptions());\n  }\n}\n\nfunction authenticatorOptionValidator(options) {\n  totpOptionsValidator(options);\n  if (typeof options.keyDecoder !== 'function') {\n    throw new Error('Expecting options.keyDecoder to be a function.');\n  }\n  if (options.keyEncoder && typeof options.keyEncoder !== 'function') {\n    throw new Error('Expecting options.keyEncoder to be a function.');\n  }\n}\nfunction authenticatorDefaultOptions() {\n  const options = {\n    algorithm: exports.HashAlgorithms.SHA1,\n    createDigest: createDigestPlaceholder,\n    createHmacKey: totpCreateHmacKey,\n    digits: 6,\n    encoding: exports.KeyEncodings.HEX,\n    epoch: Date.now(),\n    step: 30,\n    window: 0\n  };\n  return options;\n}\nfunction authenticatorOptions(opt) {\n  const options = { ...authenticatorDefaultOptions(),\n    ...opt\n  };\n  authenticatorOptionValidator(options);\n  return Object.freeze(options);\n}\nfunction authenticatorEncoder(secret, options) {\n  return options.keyEncoder(secret, options.encoding);\n}\nfunction authenticatorDecoder(secret, options) {\n  return options.keyDecoder(secret, options.encoding);\n}\nfunction authenticatorGenerateSecret(numberOfBytes, options) {\n  const key = options.createRandomBytes(numberOfBytes, options.encoding);\n  return authenticatorEncoder(key, options);\n}\nfunction authenticatorToken(secret, options) {\n  return totpToken(authenticatorDecoder(secret, options), options);\n}\nfunction authenticatorCheckWithWindow(token, secret, options) {\n  return totpCheckWithWindow(token, authenticatorDecoder(secret, options), options);\n}\nclass Authenticator extends TOTP {\n  create(defaultOptions = {}) {\n    return new Authenticator(defaultOptions);\n  }\n  allOptions() {\n    return authenticatorOptions(this.options);\n  }\n  generate(secret) {\n    return authenticatorToken(secret, this.allOptions());\n  }\n  checkDelta(token, secret) {\n    return authenticatorCheckWithWindow(token, secret, this.allOptions());\n  }\n  encode(secret) {\n    return authenticatorEncoder(secret, this.allOptions());\n  }\n  decode(secret) {\n    return authenticatorDecoder(secret, this.allOptions());\n  }\n  generateSecret(numberOfBytes = 10) {\n    return authenticatorGenerateSecret(numberOfBytes, this.allOptions());\n  }\n}\n\nexports.Authenticator = Authenticator;\nexports.HASH_ALGORITHMS = HASH_ALGORITHMS;\nexports.HOTP = HOTP;\nexports.KEY_ENCODINGS = KEY_ENCODINGS;\nexports.OTP = OTP;\nexports.STRATEGY = STRATEGY;\nexports.TOTP = TOTP;\nexports.authenticatorCheckWithWindow = authenticatorCheckWithWindow;\nexports.authenticatorDecoder = authenticatorDecoder;\nexports.authenticatorDefaultOptions = authenticatorDefaultOptions;\nexports.authenticatorEncoder = authenticatorEncoder;\nexports.authenticatorGenerateSecret = authenticatorGenerateSecret;\nexports.authenticatorOptionValidator = authenticatorOptionValidator;\nexports.authenticatorOptions = authenticatorOptions;\nexports.authenticatorToken = authenticatorToken;\nexports.createDigestPlaceholder = createDigestPlaceholder;\nexports.hotpCheck = hotpCheck;\nexports.hotpCounter = hotpCounter;\nexports.hotpCreateHmacKey = hotpCreateHmacKey;\nexports.hotpDefaultOptions = hotpDefaultOptions;\nexports.hotpDigestToToken = hotpDigestToToken;\nexports.hotpKeyuri = hotpKeyuri;\nexports.hotpOptions = hotpOptions;\nexports.hotpOptionsValidator = hotpOptionsValidator;\nexports.hotpToken = hotpToken;\nexports.isTokenValid = isTokenValid;\nexports.keyuri = keyuri;\nexports.objectValues = objectValues;\nexports.padStart = padStart;\nexports.totpCheck = totpCheck;\nexports.totpCheckByEpoch = totpCheckByEpoch;\nexports.totpCheckWithWindow = totpCheckWithWindow;\nexports.totpCounter = totpCounter;\nexports.totpCreateHmacKey = totpCreateHmacKey;\nexports.totpDefaultOptions = totpDefaultOptions;\nexports.totpEpochAvailable = totpEpochAvailable;\nexports.totpKeyuri = totpKeyuri;\nexports.totpOptions = totpOptions;\nexports.totpOptionsValidator = totpOptionsValidator;\nexports.totpPadSecret = totpPadSecret;\nexports.totpTimeRemaining = totpTimeRemaining;\nexports.totpTimeUsed = totpTimeUsed;\nexports.totpToken = totpToken;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG90cGxpYitjb3JlQDEyLjAuMS9ub2RlX21vZHVsZXMvQG90cGxpYi9jb3JlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNkJBQTZCLHNCQUFzQixLQUFLO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkIsb0JBQW9CLEtBQUs7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QixnQkFBZ0IsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVEsRUFBRSxNQUFNO0FBQzVCO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYSxFQUFFLFlBQVksRUFBRSxZQUFZLFNBQVMsUUFBUSxNQUFNO0FBQzVGO0FBQ0E7QUFDQSwyREFBMkQsb0JBQW9CLGFBQWEsYUFBYTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQSw4QkFBOEIsZ0NBQWdDO0FBQzlEO0FBQ0E7QUFDQSwyQkFBMkIsbUNBQW1DO0FBQzlEO0FBQ0Esd0JBQXdCLFlBQVksd0VBQXdFLFlBQVksc0RBQXNELE9BQU8sNkJBQTZCLE1BQU07QUFDeE47QUFDQTtBQUNBLGlDQUFpQztBQUNqQywyQ0FBMkM7QUFDM0MsS0FBSztBQUNMLG9DQUFvQztBQUNwQztBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLG1DQUFtQztBQUNuQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDJCQUEyQixhQUFhLGtCQUFrQjtBQUMxSDtBQUNBO0FBQ0EsK0RBQStELHlCQUF5QixhQUFhLGlCQUFpQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDJCQUEyQixhQUFhLFVBQVU7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQix1QkFBdUI7QUFDdkIsWUFBWTtBQUNaLHFCQUFxQjtBQUNyQixXQUFXO0FBQ1gsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixvQ0FBb0M7QUFDcEMsNEJBQTRCO0FBQzVCLG1DQUFtQztBQUNuQyw0QkFBNEI7QUFDNUIsbUNBQW1DO0FBQ25DLG9DQUFvQztBQUNwQyw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCLCtCQUErQjtBQUMvQixpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsNEJBQTRCO0FBQzVCLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsY0FBYztBQUNkLG9CQUFvQjtBQUNwQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLHdCQUF3QjtBQUN4QiwyQkFBMkI7QUFDM0IsbUJBQW1CO0FBQ25CLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsNEJBQTRCO0FBQzVCLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekIsb0JBQW9CO0FBQ3BCLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL2FydGh1cnJvc2NoL0Rlc2t0b3AvRXh0cmVtZS1Db250aW5nLW5jaWEvbm9kZV9tb2R1bGVzLy5wbnBtL0BvdHBsaWIrY29yZUAxMi4wLjEvbm9kZV9tb2R1bGVzL0BvdHBsaWIvY29yZS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBvdHBsaWIvY29yZVxuICpcbiAqIEBhdXRob3IgR2VyYWxkIFllbyA8Y29udGFjdEBmdXNlZHRob3VnaHQuY29tPlxuICogQHZlcnNpb246IDEyLjAuMVxuICogQGxpY2Vuc2U6IE1JVFxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBvYmplY3RWYWx1ZXModmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoa2V5ID0+IHZhbHVlW2tleV0pO1xufVxuKGZ1bmN0aW9uIChIYXNoQWxnb3JpdGhtcykge1xuICBIYXNoQWxnb3JpdGhtc1tcIlNIQTFcIl0gPSBcInNoYTFcIjtcbiAgSGFzaEFsZ29yaXRobXNbXCJTSEEyNTZcIl0gPSBcInNoYTI1NlwiO1xuICBIYXNoQWxnb3JpdGhtc1tcIlNIQTUxMlwiXSA9IFwic2hhNTEyXCI7XG59KShleHBvcnRzLkhhc2hBbGdvcml0aG1zIHx8IChleHBvcnRzLkhhc2hBbGdvcml0aG1zID0ge30pKTtcbmNvbnN0IEhBU0hfQUxHT1JJVEhNUyA9IG9iamVjdFZhbHVlcyhleHBvcnRzLkhhc2hBbGdvcml0aG1zKTtcbihmdW5jdGlvbiAoS2V5RW5jb2RpbmdzKSB7XG4gIEtleUVuY29kaW5nc1tcIkFTQ0lJXCJdID0gXCJhc2NpaVwiO1xuICBLZXlFbmNvZGluZ3NbXCJCQVNFNjRcIl0gPSBcImJhc2U2NFwiO1xuICBLZXlFbmNvZGluZ3NbXCJIRVhcIl0gPSBcImhleFwiO1xuICBLZXlFbmNvZGluZ3NbXCJMQVRJTjFcIl0gPSBcImxhdGluMVwiO1xuICBLZXlFbmNvZGluZ3NbXCJVVEY4XCJdID0gXCJ1dGY4XCI7XG59KShleHBvcnRzLktleUVuY29kaW5ncyB8fCAoZXhwb3J0cy5LZXlFbmNvZGluZ3MgPSB7fSkpO1xuY29uc3QgS0VZX0VOQ09ESU5HUyA9IG9iamVjdFZhbHVlcyhleHBvcnRzLktleUVuY29kaW5ncyk7XG4oZnVuY3Rpb24gKFN0cmF0ZWd5KSB7XG4gIFN0cmF0ZWd5W1wiSE9UUFwiXSA9IFwiaG90cFwiO1xuICBTdHJhdGVneVtcIlRPVFBcIl0gPSBcInRvdHBcIjtcbn0pKGV4cG9ydHMuU3RyYXRlZ3kgfHwgKGV4cG9ydHMuU3RyYXRlZ3kgPSB7fSkpO1xuY29uc3QgU1RSQVRFR1kgPSBvYmplY3RWYWx1ZXMoZXhwb3J0cy5TdHJhdGVneSk7XG5jb25zdCBjcmVhdGVEaWdlc3RQbGFjZWhvbGRlciA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhbiBvcHRpb25zLmNyZWF0ZURpZ2VzdCBpbXBsZW1lbnRhdGlvbi4nKTtcbn07XG5mdW5jdGlvbiBpc1Rva2VuVmFsaWQodmFsdWUpIHtcbiAgcmV0dXJuIC9eKFxcZCspJC8udGVzdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBwYWRTdGFydCh2YWx1ZSwgbWF4TGVuZ3RoLCBmaWxsU3RyaW5nKSB7XG4gIGlmICh2YWx1ZS5sZW5ndGggPj0gbWF4TGVuZ3RoKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNvbnN0IHBhZGRpbmcgPSBBcnJheShtYXhMZW5ndGggKyAxKS5qb2luKGZpbGxTdHJpbmcpO1xuICByZXR1cm4gYCR7cGFkZGluZ30ke3ZhbHVlfWAuc2xpY2UoLTEgKiBtYXhMZW5ndGgpO1xufVxuZnVuY3Rpb24ga2V5dXJpKG9wdGlvbnMpIHtcbiAgY29uc3QgdG1wbCA9IGBvdHBhdXRoOi8vJHtvcHRpb25zLnR5cGV9L3tsYWJlbFByZWZpeH06e2FjY291bnROYW1lfT9zZWNyZXQ9e3NlY3JldH17cXVlcnl9YDtcbiAgY29uc3QgcGFyYW1zID0gW107XG4gIGlmIChTVFJBVEVHWS5pbmRleE9mKG9wdGlvbnMudHlwZSkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3Rpbmcgb3B0aW9ucy50eXBlIHRvIGJlIG9uZSBvZiAke1NUUkFURUdZLmpvaW4oJywgJyl9LiBSZWNlaXZlZCAke29wdGlvbnMudHlwZX0uYCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2hvdHAnKSB7XG4gICAgaWYgKG9wdGlvbnMuY291bnRlciA9PSBudWxsIHx8IHR5cGVvZiBvcHRpb25zLmNvdW50ZXIgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGluZyBvcHRpb25zLmNvdW50ZXIgdG8gYmUgYSBudW1iZXIgd2hlbiBvcHRpb25zLnR5cGUgaXMgXCJob3RwXCIuJyk7XG4gICAgfVxuICAgIHBhcmFtcy5wdXNoKGAmY291bnRlcj0ke29wdGlvbnMuY291bnRlcn1gKTtcbiAgfVxuICBpZiAob3B0aW9ucy50eXBlID09PSAndG90cCcgJiYgb3B0aW9ucy5zdGVwKSB7XG4gICAgcGFyYW1zLnB1c2goYCZwZXJpb2Q9JHtvcHRpb25zLnN0ZXB9YCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZGlnaXRzKSB7XG4gICAgcGFyYW1zLnB1c2goYCZkaWdpdHM9JHtvcHRpb25zLmRpZ2l0c31gKTtcbiAgfVxuICBpZiAob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgICBwYXJhbXMucHVzaChgJmFsZ29yaXRobT0ke29wdGlvbnMuYWxnb3JpdGhtLnRvVXBwZXJDYXNlKCl9YCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuaXNzdWVyKSB7XG4gICAgcGFyYW1zLnB1c2goYCZpc3N1ZXI9JHtlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5pc3N1ZXIpfWApO1xuICB9XG4gIHJldHVybiB0bXBsLnJlcGxhY2UoJ3tsYWJlbFByZWZpeH0nLCBlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5pc3N1ZXIgfHwgb3B0aW9ucy5hY2NvdW50TmFtZSkpLnJlcGxhY2UoJ3thY2NvdW50TmFtZX0nLCBlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5hY2NvdW50TmFtZSkpLnJlcGxhY2UoJ3tzZWNyZXR9Jywgb3B0aW9ucy5zZWNyZXQpLnJlcGxhY2UoJ3txdWVyeX0nLCBwYXJhbXMuam9pbignJykpO1xufVxuY2xhc3MgT1RQIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdE9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2RlZmF1bHRPcHRpb25zID0gT2JqZWN0LmZyZWV6ZSh7IC4uLmRlZmF1bHRPcHRpb25zXG4gICAgfSk7XG4gICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5mcmVlemUoe30pO1xuICB9XG4gIGNyZWF0ZShkZWZhdWx0T3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBPVFAoZGVmYXVsdE9wdGlvbnMpO1xuICB9XG4gIGNsb25lKGRlZmF1bHRPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuY3JlYXRlKHsgLi4udGhpcy5fZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5kZWZhdWx0T3B0aW9uc1xuICAgIH0pO1xuICAgIGluc3RhbmNlLm9wdGlvbnMgPSB0aGlzLl9vcHRpb25zO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLnRoaXMuX2RlZmF1bHRPcHRpb25zLFxuICAgICAgLi4udGhpcy5fb3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmZyZWV6ZSh7IC4uLnRoaXMuX29wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgYWxsT3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICB9XG4gIHJlc2V0T3B0aW9ucygpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaG90cE9wdGlvbnNWYWxpZGF0b3Iob3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMuY3JlYXRlRGlnZXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3Rpbmcgb3B0aW9ucy5jcmVhdGVEaWdlc3QgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMuY3JlYXRlSG1hY0tleSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nIG9wdGlvbnMuY3JlYXRlSG1hY0tleSB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5kaWdpdHMgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3Rpbmcgb3B0aW9ucy5kaWdpdHMgdG8gYmUgYSBudW1iZXIuJyk7XG4gIH1cbiAgaWYgKCFvcHRpb25zLmFsZ29yaXRobSB8fCBIQVNIX0FMR09SSVRITVMuaW5kZXhPZihvcHRpb25zLmFsZ29yaXRobSkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3Rpbmcgb3B0aW9ucy5hbGdvcml0aG0gdG8gYmUgb25lIG9mICR7SEFTSF9BTEdPUklUSE1TLmpvaW4oJywgJyl9LiBSZWNlaXZlZCAke29wdGlvbnMuYWxnb3JpdGhtfS5gKTtcbiAgfVxuICBpZiAoIW9wdGlvbnMuZW5jb2RpbmcgfHwgS0VZX0VOQ09ESU5HUy5pbmRleE9mKG9wdGlvbnMuZW5jb2RpbmcpIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0aW5nIG9wdGlvbnMuZW5jb2RpbmcgdG8gYmUgb25lIG9mICR7S0VZX0VOQ09ESU5HUy5qb2luKCcsICcpfS4gUmVjZWl2ZWQgJHtvcHRpb25zLmVuY29kaW5nfS5gKTtcbiAgfVxufVxuY29uc3QgaG90cENyZWF0ZUhtYWNLZXkgPSAoYWxnb3JpdGhtLCBzZWNyZXQsIGVuY29kaW5nKSA9PiB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNyZXQsIGVuY29kaW5nKS50b1N0cmluZygnaGV4Jyk7XG59O1xuZnVuY3Rpb24gaG90cERlZmF1bHRPcHRpb25zKCkge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGFsZ29yaXRobTogZXhwb3J0cy5IYXNoQWxnb3JpdGhtcy5TSEExLFxuICAgIGNyZWF0ZUhtYWNLZXk6IGhvdHBDcmVhdGVIbWFjS2V5LFxuICAgIGNyZWF0ZURpZ2VzdDogY3JlYXRlRGlnZXN0UGxhY2Vob2xkZXIsXG4gICAgZGlnaXRzOiA2LFxuICAgIGVuY29kaW5nOiBleHBvcnRzLktleUVuY29kaW5ncy5BU0NJSVxuICB9O1xuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGhvdHBPcHRpb25zKG9wdCkge1xuICBjb25zdCBvcHRpb25zID0geyAuLi5ob3RwRGVmYXVsdE9wdGlvbnMoKSxcbiAgICAuLi5vcHRcbiAgfTtcbiAgaG90cE9wdGlvbnNWYWxpZGF0b3Iob3B0aW9ucyk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaG90cENvdW50ZXIoY291bnRlcikge1xuICBjb25zdCBoZXhDb3VudGVyID0gY291bnRlci50b1N0cmluZygxNik7XG4gIHJldHVybiBwYWRTdGFydChoZXhDb3VudGVyLCAxNiwgJzAnKTtcbn1cbmZ1bmN0aW9uIGhvdHBEaWdlc3RUb1Rva2VuKGhleERpZ2VzdCwgZGlnaXRzKSB7XG4gIGNvbnN0IGRpZ2VzdCA9IEJ1ZmZlci5mcm9tKGhleERpZ2VzdCwgJ2hleCcpO1xuICBjb25zdCBvZmZzZXQgPSBkaWdlc3RbZGlnZXN0Lmxlbmd0aCAtIDFdICYgMHhmO1xuICBjb25zdCBiaW5hcnkgPSAoZGlnZXN0W29mZnNldF0gJiAweDdmKSA8PCAyNCB8IChkaWdlc3Rbb2Zmc2V0ICsgMV0gJiAweGZmKSA8PCAxNiB8IChkaWdlc3Rbb2Zmc2V0ICsgMl0gJiAweGZmKSA8PCA4IHwgZGlnZXN0W29mZnNldCArIDNdICYgMHhmZjtcbiAgY29uc3QgdG9rZW4gPSBiaW5hcnkgJSBNYXRoLnBvdygxMCwgZGlnaXRzKTtcbiAgcmV0dXJuIHBhZFN0YXJ0KFN0cmluZyh0b2tlbiksIGRpZ2l0cywgJzAnKTtcbn1cbmZ1bmN0aW9uIGhvdHBEaWdlc3Qoc2VjcmV0LCBjb3VudGVyLCBvcHRpb25zKSB7XG4gIGNvbnN0IGhleENvdW50ZXIgPSBob3RwQ291bnRlcihjb3VudGVyKTtcbiAgY29uc3QgaG1hY0tleSA9IG9wdGlvbnMuY3JlYXRlSG1hY0tleShvcHRpb25zLmFsZ29yaXRobSwgc2VjcmV0LCBvcHRpb25zLmVuY29kaW5nKTtcbiAgcmV0dXJuIG9wdGlvbnMuY3JlYXRlRGlnZXN0KG9wdGlvbnMuYWxnb3JpdGhtLCBobWFjS2V5LCBoZXhDb3VudGVyKTtcbn1cbmZ1bmN0aW9uIGhvdHBUb2tlbihzZWNyZXQsIGNvdW50ZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgaGV4RGlnZXN0ID0gb3B0aW9ucy5kaWdlc3QgfHwgaG90cERpZ2VzdChzZWNyZXQsIGNvdW50ZXIsIG9wdGlvbnMpO1xuICByZXR1cm4gaG90cERpZ2VzdFRvVG9rZW4oaGV4RGlnZXN0LCBvcHRpb25zLmRpZ2l0cyk7XG59XG5mdW5jdGlvbiBob3RwQ2hlY2sodG9rZW4sIHNlY3JldCwgY291bnRlciwgb3B0aW9ucykge1xuICBpZiAoIWlzVG9rZW5WYWxpZCh0b2tlbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc3lzdGVtVG9rZW4gPSBob3RwVG9rZW4oc2VjcmV0LCBjb3VudGVyLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRva2VuID09PSBzeXN0ZW1Ub2tlbjtcbn1cbmZ1bmN0aW9uIGhvdHBLZXl1cmkoYWNjb3VudE5hbWUsIGlzc3Vlciwgc2VjcmV0LCBjb3VudGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBrZXl1cmkoe1xuICAgIGFsZ29yaXRobTogb3B0aW9ucy5hbGdvcml0aG0sXG4gICAgZGlnaXRzOiBvcHRpb25zLmRpZ2l0cyxcbiAgICB0eXBlOiBleHBvcnRzLlN0cmF0ZWd5LkhPVFAsXG4gICAgYWNjb3VudE5hbWUsXG4gICAgY291bnRlcixcbiAgICBpc3N1ZXIsXG4gICAgc2VjcmV0XG4gIH0pO1xufVxuY2xhc3MgSE9UUCBleHRlbmRzIE9UUCB7XG4gIGNyZWF0ZShkZWZhdWx0T3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBIT1RQKGRlZmF1bHRPcHRpb25zKTtcbiAgfVxuICBhbGxPcHRpb25zKCkge1xuICAgIHJldHVybiBob3RwT3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICB9XG4gIGdlbmVyYXRlKHNlY3JldCwgY291bnRlcikge1xuICAgIHJldHVybiBob3RwVG9rZW4oc2VjcmV0LCBjb3VudGVyLCB0aGlzLmFsbE9wdGlvbnMoKSk7XG4gIH1cbiAgY2hlY2sodG9rZW4sIHNlY3JldCwgY291bnRlcikge1xuICAgIHJldHVybiBob3RwQ2hlY2sodG9rZW4sIHNlY3JldCwgY291bnRlciwgdGhpcy5hbGxPcHRpb25zKCkpO1xuICB9XG4gIHZlcmlmeShvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RpbmcgYXJndW1lbnQgMCBvZiB2ZXJpZnkgdG8gYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNoZWNrKG9wdHMudG9rZW4sIG9wdHMuc2VjcmV0LCBvcHRzLmNvdW50ZXIpO1xuICB9XG4gIGtleXVyaShhY2NvdW50TmFtZSwgaXNzdWVyLCBzZWNyZXQsIGNvdW50ZXIpIHtcbiAgICByZXR1cm4gaG90cEtleXVyaShhY2NvdW50TmFtZSwgaXNzdWVyLCBzZWNyZXQsIGNvdW50ZXIsIHRoaXMuYWxsT3B0aW9ucygpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVdpbmRvd0JvdW5kcyh3aW4pIHtcbiAgaWYgKHR5cGVvZiB3aW4gPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIFtNYXRoLmFicyh3aW4pLCBNYXRoLmFicyh3aW4pXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh3aW4pKSB7XG4gICAgY29uc3QgW3Bhc3QsIGZ1dHVyZV0gPSB3aW47XG4gICAgaWYgKHR5cGVvZiBwYXN0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgZnV0dXJlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIFtNYXRoLmFicyhwYXN0KSwgTWF0aC5hYnMoZnV0dXJlKV07XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nIG9wdGlvbnMud2luZG93IHRvIGJlIGFuIG51bWJlciBvciBbbnVtYmVyLCBudW1iZXJdLicpO1xufVxuZnVuY3Rpb24gdG90cE9wdGlvbnNWYWxpZGF0b3Iob3B0aW9ucykge1xuICBob3RwT3B0aW9uc1ZhbGlkYXRvcihvcHRpb25zKTtcbiAgcGFyc2VXaW5kb3dCb3VuZHMob3B0aW9ucy53aW5kb3cpO1xuICBpZiAodHlwZW9mIG9wdGlvbnMuZXBvY2ggIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3Rpbmcgb3B0aW9ucy5lcG9jaCB0byBiZSBhIG51bWJlci4nKTtcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMuc3RlcCAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGluZyBvcHRpb25zLnN0ZXAgdG8gYmUgYSBudW1iZXIuJyk7XG4gIH1cbn1cbmNvbnN0IHRvdHBQYWRTZWNyZXQgPSAoc2VjcmV0LCBlbmNvZGluZywgbWluTGVuZ3RoKSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRMZW5ndGggPSBzZWNyZXQubGVuZ3RoO1xuICBjb25zdCBoZXhTZWNyZXQgPSBCdWZmZXIuZnJvbShzZWNyZXQsIGVuY29kaW5nKS50b1N0cmluZygnaGV4Jyk7XG4gIGlmIChjdXJyZW50TGVuZ3RoIDwgbWluTGVuZ3RoKSB7XG4gICAgY29uc3QgbmV3U2VjcmV0ID0gbmV3IEFycmF5KG1pbkxlbmd0aCAtIGN1cnJlbnRMZW5ndGggKyAxKS5qb2luKGhleFNlY3JldCk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5ld1NlY3JldCwgJ2hleCcpLnNsaWNlKDAsIG1pbkxlbmd0aCkudG9TdHJpbmcoJ2hleCcpO1xuICB9XG4gIHJldHVybiBoZXhTZWNyZXQ7XG59O1xuY29uc3QgdG90cENyZWF0ZUhtYWNLZXkgPSAoYWxnb3JpdGhtLCBzZWNyZXQsIGVuY29kaW5nKSA9PiB7XG4gIHN3aXRjaCAoYWxnb3JpdGhtKSB7XG4gICAgY2FzZSBleHBvcnRzLkhhc2hBbGdvcml0aG1zLlNIQTE6XG4gICAgICByZXR1cm4gdG90cFBhZFNlY3JldChzZWNyZXQsIGVuY29kaW5nLCAyMCk7XG4gICAgY2FzZSBleHBvcnRzLkhhc2hBbGdvcml0aG1zLlNIQTI1NjpcbiAgICAgIHJldHVybiB0b3RwUGFkU2VjcmV0KHNlY3JldCwgZW5jb2RpbmcsIDMyKTtcbiAgICBjYXNlIGV4cG9ydHMuSGFzaEFsZ29yaXRobXMuU0hBNTEyOlxuICAgICAgcmV0dXJuIHRvdHBQYWRTZWNyZXQoc2VjcmV0LCBlbmNvZGluZywgNjQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGluZyBhbGdvcml0aG0gdG8gYmUgb25lIG9mICR7SEFTSF9BTEdPUklUSE1TLmpvaW4oJywgJyl9LiBSZWNlaXZlZCAke2FsZ29yaXRobX0uYCk7XG4gIH1cbn07XG5mdW5jdGlvbiB0b3RwRGVmYXVsdE9wdGlvbnMoKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgYWxnb3JpdGhtOiBleHBvcnRzLkhhc2hBbGdvcml0aG1zLlNIQTEsXG4gICAgY3JlYXRlRGlnZXN0OiBjcmVhdGVEaWdlc3RQbGFjZWhvbGRlcixcbiAgICBjcmVhdGVIbWFjS2V5OiB0b3RwQ3JlYXRlSG1hY0tleSxcbiAgICBkaWdpdHM6IDYsXG4gICAgZW5jb2Rpbmc6IGV4cG9ydHMuS2V5RW5jb2RpbmdzLkFTQ0lJLFxuICAgIGVwb2NoOiBEYXRlLm5vdygpLFxuICAgIHN0ZXA6IDMwLFxuICAgIHdpbmRvdzogMFxuICB9O1xuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIHRvdHBPcHRpb25zKG9wdCkge1xuICBjb25zdCBvcHRpb25zID0geyAuLi50b3RwRGVmYXVsdE9wdGlvbnMoKSxcbiAgICAuLi5vcHRcbiAgfTtcbiAgdG90cE9wdGlvbnNWYWxpZGF0b3Iob3B0aW9ucyk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gdG90cENvdW50ZXIoZXBvY2gsIHN0ZXApIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZXBvY2ggLyBzdGVwIC8gMTAwMCk7XG59XG5mdW5jdGlvbiB0b3RwVG9rZW4oc2VjcmV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvdW50ZXIgPSB0b3RwQ291bnRlcihvcHRpb25zLmVwb2NoLCBvcHRpb25zLnN0ZXApO1xuICByZXR1cm4gaG90cFRva2VuKHNlY3JldCwgY291bnRlciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB0b3RwRXBvY2hzSW5XaW5kb3coZXBvY2gsIGRpcmVjdGlvbiwgZGVsdGFQZXJFcG9jaCwgbnVtT2ZFcG9jaGVzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBpZiAobnVtT2ZFcG9jaGVzID09PSAwKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmb3IgKGxldCBpID0gMTsgaSA8PSBudW1PZkVwb2NoZXM7IGkrKykge1xuICAgIGNvbnN0IGRlbHRhID0gZGlyZWN0aW9uICogaSAqIGRlbHRhUGVyRXBvY2g7XG4gICAgcmVzdWx0LnB1c2goZXBvY2ggKyBkZWx0YSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvdHBFcG9jaEF2YWlsYWJsZShlcG9jaCwgc3RlcCwgd2luKSB7XG4gIGNvbnN0IGJvdW5kcyA9IHBhcnNlV2luZG93Qm91bmRzKHdpbik7XG4gIGNvbnN0IGRlbHRhID0gc3RlcCAqIDEwMDA7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogZXBvY2gsXG4gICAgcGFzdDogdG90cEVwb2Noc0luV2luZG93KGVwb2NoLCAtMSwgZGVsdGEsIGJvdW5kc1swXSksXG4gICAgZnV0dXJlOiB0b3RwRXBvY2hzSW5XaW5kb3coZXBvY2gsIDEsIGRlbHRhLCBib3VuZHNbMV0pXG4gIH07XG59XG5mdW5jdGlvbiB0b3RwQ2hlY2sodG9rZW4sIHNlY3JldCwgb3B0aW9ucykge1xuICBpZiAoIWlzVG9rZW5WYWxpZCh0b2tlbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc3lzdGVtVG9rZW4gPSB0b3RwVG9rZW4oc2VjcmV0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHRva2VuID09PSBzeXN0ZW1Ub2tlbjtcbn1cbmZ1bmN0aW9uIHRvdHBDaGVja0J5RXBvY2goZXBvY2hzLCB0b2tlbiwgc2VjcmV0LCBvcHRpb25zKSB7XG4gIGxldCBwb3NpdGlvbiA9IG51bGw7XG4gIGVwb2Nocy5zb21lKChlcG9jaCwgaWR4KSA9PiB7XG4gICAgaWYgKHRvdHBDaGVjayh0b2tlbiwgc2VjcmV0LCB7IC4uLm9wdGlvbnMsXG4gICAgICBlcG9jaFxuICAgIH0pKSB7XG4gICAgICBwb3NpdGlvbiA9IGlkeCArIDE7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbiAgcmV0dXJuIHBvc2l0aW9uO1xufVxuZnVuY3Rpb24gdG90cENoZWNrV2l0aFdpbmRvdyh0b2tlbiwgc2VjcmV0LCBvcHRpb25zKSB7XG4gIGlmICh0b3RwQ2hlY2sodG9rZW4sIHNlY3JldCwgb3B0aW9ucykpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBlcG9jaHMgPSB0b3RwRXBvY2hBdmFpbGFibGUob3B0aW9ucy5lcG9jaCwgb3B0aW9ucy5zdGVwLCBvcHRpb25zLndpbmRvdyk7XG4gIGNvbnN0IGJhY2t3YXJkID0gdG90cENoZWNrQnlFcG9jaChlcG9jaHMucGFzdCwgdG9rZW4sIHNlY3JldCwgb3B0aW9ucyk7XG4gIGlmIChiYWNrd2FyZCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBiYWNrd2FyZCAqIC0xO1xuICB9XG4gIHJldHVybiB0b3RwQ2hlY2tCeUVwb2NoKGVwb2Nocy5mdXR1cmUsIHRva2VuLCBzZWNyZXQsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gdG90cFRpbWVVc2VkKGVwb2NoLCBzdGVwKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKGVwb2NoIC8gMTAwMCkgJSBzdGVwO1xufVxuZnVuY3Rpb24gdG90cFRpbWVSZW1haW5pbmcoZXBvY2gsIHN0ZXApIHtcbiAgcmV0dXJuIHN0ZXAgLSB0b3RwVGltZVVzZWQoZXBvY2gsIHN0ZXApO1xufVxuZnVuY3Rpb24gdG90cEtleXVyaShhY2NvdW50TmFtZSwgaXNzdWVyLCBzZWNyZXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGtleXVyaSh7XG4gICAgYWxnb3JpdGhtOiBvcHRpb25zLmFsZ29yaXRobSxcbiAgICBkaWdpdHM6IG9wdGlvbnMuZGlnaXRzLFxuICAgIHN0ZXA6IG9wdGlvbnMuc3RlcCxcbiAgICB0eXBlOiBleHBvcnRzLlN0cmF0ZWd5LlRPVFAsXG4gICAgYWNjb3VudE5hbWUsXG4gICAgaXNzdWVyLFxuICAgIHNlY3JldFxuICB9KTtcbn1cbmNsYXNzIFRPVFAgZXh0ZW5kcyBIT1RQIHtcbiAgY3JlYXRlKGRlZmF1bHRPcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFRPVFAoZGVmYXVsdE9wdGlvbnMpO1xuICB9XG4gIGFsbE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRvdHBPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gIH1cbiAgZ2VuZXJhdGUoc2VjcmV0KSB7XG4gICAgcmV0dXJuIHRvdHBUb2tlbihzZWNyZXQsIHRoaXMuYWxsT3B0aW9ucygpKTtcbiAgfVxuICBjaGVja0RlbHRhKHRva2VuLCBzZWNyZXQpIHtcbiAgICByZXR1cm4gdG90cENoZWNrV2l0aFdpbmRvdyh0b2tlbiwgc2VjcmV0LCB0aGlzLmFsbE9wdGlvbnMoKSk7XG4gIH1cbiAgY2hlY2sodG9rZW4sIHNlY3JldCkge1xuICAgIGNvbnN0IGRlbHRhID0gdGhpcy5jaGVja0RlbHRhKHRva2VuLCBzZWNyZXQpO1xuICAgIHJldHVybiB0eXBlb2YgZGVsdGEgPT09ICdudW1iZXInO1xuICB9XG4gIHZlcmlmeShvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RpbmcgYXJndW1lbnQgMCBvZiB2ZXJpZnkgdG8gYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNoZWNrKG9wdHMudG9rZW4sIG9wdHMuc2VjcmV0KTtcbiAgfVxuICB0aW1lUmVtYWluaW5nKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmFsbE9wdGlvbnMoKTtcbiAgICByZXR1cm4gdG90cFRpbWVSZW1haW5pbmcob3B0aW9ucy5lcG9jaCwgb3B0aW9ucy5zdGVwKTtcbiAgfVxuICB0aW1lVXNlZCgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5hbGxPcHRpb25zKCk7XG4gICAgcmV0dXJuIHRvdHBUaW1lVXNlZChvcHRpb25zLmVwb2NoLCBvcHRpb25zLnN0ZXApO1xuICB9XG4gIGtleXVyaShhY2NvdW50TmFtZSwgaXNzdWVyLCBzZWNyZXQpIHtcbiAgICByZXR1cm4gdG90cEtleXVyaShhY2NvdW50TmFtZSwgaXNzdWVyLCBzZWNyZXQsIHRoaXMuYWxsT3B0aW9ucygpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdXRoZW50aWNhdG9yT3B0aW9uVmFsaWRhdG9yKG9wdGlvbnMpIHtcbiAgdG90cE9wdGlvbnNWYWxpZGF0b3Iob3B0aW9ucyk7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5rZXlEZWNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3Rpbmcgb3B0aW9ucy5rZXlEZWNvZGVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMua2V5RW5jb2RlciAmJiB0eXBlb2Ygb3B0aW9ucy5rZXlFbmNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3Rpbmcgb3B0aW9ucy5rZXlFbmNvZGVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGF1dGhlbnRpY2F0b3JEZWZhdWx0T3B0aW9ucygpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBhbGdvcml0aG06IGV4cG9ydHMuSGFzaEFsZ29yaXRobXMuU0hBMSxcbiAgICBjcmVhdGVEaWdlc3Q6IGNyZWF0ZURpZ2VzdFBsYWNlaG9sZGVyLFxuICAgIGNyZWF0ZUhtYWNLZXk6IHRvdHBDcmVhdGVIbWFjS2V5LFxuICAgIGRpZ2l0czogNixcbiAgICBlbmNvZGluZzogZXhwb3J0cy5LZXlFbmNvZGluZ3MuSEVYLFxuICAgIGVwb2NoOiBEYXRlLm5vdygpLFxuICAgIHN0ZXA6IDMwLFxuICAgIHdpbmRvdzogMFxuICB9O1xuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGF1dGhlbnRpY2F0b3JPcHRpb25zKG9wdCkge1xuICBjb25zdCBvcHRpb25zID0geyAuLi5hdXRoZW50aWNhdG9yRGVmYXVsdE9wdGlvbnMoKSxcbiAgICAuLi5vcHRcbiAgfTtcbiAgYXV0aGVudGljYXRvck9wdGlvblZhbGlkYXRvcihvcHRpb25zKTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUob3B0aW9ucyk7XG59XG5mdW5jdGlvbiBhdXRoZW50aWNhdG9yRW5jb2RlcihzZWNyZXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMua2V5RW5jb2RlcihzZWNyZXQsIG9wdGlvbnMuZW5jb2RpbmcpO1xufVxuZnVuY3Rpb24gYXV0aGVudGljYXRvckRlY29kZXIoc2VjcmV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmtleURlY29kZXIoc2VjcmV0LCBvcHRpb25zLmVuY29kaW5nKTtcbn1cbmZ1bmN0aW9uIGF1dGhlbnRpY2F0b3JHZW5lcmF0ZVNlY3JldChudW1iZXJPZkJ5dGVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IGtleSA9IG9wdGlvbnMuY3JlYXRlUmFuZG9tQnl0ZXMobnVtYmVyT2ZCeXRlcywgb3B0aW9ucy5lbmNvZGluZyk7XG4gIHJldHVybiBhdXRoZW50aWNhdG9yRW5jb2RlcihrZXksIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gYXV0aGVudGljYXRvclRva2VuKHNlY3JldCwgb3B0aW9ucykge1xuICByZXR1cm4gdG90cFRva2VuKGF1dGhlbnRpY2F0b3JEZWNvZGVyKHNlY3JldCwgb3B0aW9ucyksIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gYXV0aGVudGljYXRvckNoZWNrV2l0aFdpbmRvdyh0b2tlbiwgc2VjcmV0LCBvcHRpb25zKSB7XG4gIHJldHVybiB0b3RwQ2hlY2tXaXRoV2luZG93KHRva2VuLCBhdXRoZW50aWNhdG9yRGVjb2RlcihzZWNyZXQsIG9wdGlvbnMpLCBvcHRpb25zKTtcbn1cbmNsYXNzIEF1dGhlbnRpY2F0b3IgZXh0ZW5kcyBUT1RQIHtcbiAgY3JlYXRlKGRlZmF1bHRPcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0b3IoZGVmYXVsdE9wdGlvbnMpO1xuICB9XG4gIGFsbE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0b3JPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gIH1cbiAgZ2VuZXJhdGUoc2VjcmV0KSB7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0b3JUb2tlbihzZWNyZXQsIHRoaXMuYWxsT3B0aW9ucygpKTtcbiAgfVxuICBjaGVja0RlbHRhKHRva2VuLCBzZWNyZXQpIHtcbiAgICByZXR1cm4gYXV0aGVudGljYXRvckNoZWNrV2l0aFdpbmRvdyh0b2tlbiwgc2VjcmV0LCB0aGlzLmFsbE9wdGlvbnMoKSk7XG4gIH1cbiAgZW5jb2RlKHNlY3JldCkge1xuICAgIHJldHVybiBhdXRoZW50aWNhdG9yRW5jb2RlcihzZWNyZXQsIHRoaXMuYWxsT3B0aW9ucygpKTtcbiAgfVxuICBkZWNvZGUoc2VjcmV0KSB7XG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0b3JEZWNvZGVyKHNlY3JldCwgdGhpcy5hbGxPcHRpb25zKCkpO1xuICB9XG4gIGdlbmVyYXRlU2VjcmV0KG51bWJlck9mQnl0ZXMgPSAxMCkge1xuICAgIHJldHVybiBhdXRoZW50aWNhdG9yR2VuZXJhdGVTZWNyZXQobnVtYmVyT2ZCeXRlcywgdGhpcy5hbGxPcHRpb25zKCkpO1xuICB9XG59XG5cbmV4cG9ydHMuQXV0aGVudGljYXRvciA9IEF1dGhlbnRpY2F0b3I7XG5leHBvcnRzLkhBU0hfQUxHT1JJVEhNUyA9IEhBU0hfQUxHT1JJVEhNUztcbmV4cG9ydHMuSE9UUCA9IEhPVFA7XG5leHBvcnRzLktFWV9FTkNPRElOR1MgPSBLRVlfRU5DT0RJTkdTO1xuZXhwb3J0cy5PVFAgPSBPVFA7XG5leHBvcnRzLlNUUkFURUdZID0gU1RSQVRFR1k7XG5leHBvcnRzLlRPVFAgPSBUT1RQO1xuZXhwb3J0cy5hdXRoZW50aWNhdG9yQ2hlY2tXaXRoV2luZG93ID0gYXV0aGVudGljYXRvckNoZWNrV2l0aFdpbmRvdztcbmV4cG9ydHMuYXV0aGVudGljYXRvckRlY29kZXIgPSBhdXRoZW50aWNhdG9yRGVjb2RlcjtcbmV4cG9ydHMuYXV0aGVudGljYXRvckRlZmF1bHRPcHRpb25zID0gYXV0aGVudGljYXRvckRlZmF1bHRPcHRpb25zO1xuZXhwb3J0cy5hdXRoZW50aWNhdG9yRW5jb2RlciA9IGF1dGhlbnRpY2F0b3JFbmNvZGVyO1xuZXhwb3J0cy5hdXRoZW50aWNhdG9yR2VuZXJhdGVTZWNyZXQgPSBhdXRoZW50aWNhdG9yR2VuZXJhdGVTZWNyZXQ7XG5leHBvcnRzLmF1dGhlbnRpY2F0b3JPcHRpb25WYWxpZGF0b3IgPSBhdXRoZW50aWNhdG9yT3B0aW9uVmFsaWRhdG9yO1xuZXhwb3J0cy5hdXRoZW50aWNhdG9yT3B0aW9ucyA9IGF1dGhlbnRpY2F0b3JPcHRpb25zO1xuZXhwb3J0cy5hdXRoZW50aWNhdG9yVG9rZW4gPSBhdXRoZW50aWNhdG9yVG9rZW47XG5leHBvcnRzLmNyZWF0ZURpZ2VzdFBsYWNlaG9sZGVyID0gY3JlYXRlRGlnZXN0UGxhY2Vob2xkZXI7XG5leHBvcnRzLmhvdHBDaGVjayA9IGhvdHBDaGVjaztcbmV4cG9ydHMuaG90cENvdW50ZXIgPSBob3RwQ291bnRlcjtcbmV4cG9ydHMuaG90cENyZWF0ZUhtYWNLZXkgPSBob3RwQ3JlYXRlSG1hY0tleTtcbmV4cG9ydHMuaG90cERlZmF1bHRPcHRpb25zID0gaG90cERlZmF1bHRPcHRpb25zO1xuZXhwb3J0cy5ob3RwRGlnZXN0VG9Ub2tlbiA9IGhvdHBEaWdlc3RUb1Rva2VuO1xuZXhwb3J0cy5ob3RwS2V5dXJpID0gaG90cEtleXVyaTtcbmV4cG9ydHMuaG90cE9wdGlvbnMgPSBob3RwT3B0aW9ucztcbmV4cG9ydHMuaG90cE9wdGlvbnNWYWxpZGF0b3IgPSBob3RwT3B0aW9uc1ZhbGlkYXRvcjtcbmV4cG9ydHMuaG90cFRva2VuID0gaG90cFRva2VuO1xuZXhwb3J0cy5pc1Rva2VuVmFsaWQgPSBpc1Rva2VuVmFsaWQ7XG5leHBvcnRzLmtleXVyaSA9IGtleXVyaTtcbmV4cG9ydHMub2JqZWN0VmFsdWVzID0gb2JqZWN0VmFsdWVzO1xuZXhwb3J0cy5wYWRTdGFydCA9IHBhZFN0YXJ0O1xuZXhwb3J0cy50b3RwQ2hlY2sgPSB0b3RwQ2hlY2s7XG5leHBvcnRzLnRvdHBDaGVja0J5RXBvY2ggPSB0b3RwQ2hlY2tCeUVwb2NoO1xuZXhwb3J0cy50b3RwQ2hlY2tXaXRoV2luZG93ID0gdG90cENoZWNrV2l0aFdpbmRvdztcbmV4cG9ydHMudG90cENvdW50ZXIgPSB0b3RwQ291bnRlcjtcbmV4cG9ydHMudG90cENyZWF0ZUhtYWNLZXkgPSB0b3RwQ3JlYXRlSG1hY0tleTtcbmV4cG9ydHMudG90cERlZmF1bHRPcHRpb25zID0gdG90cERlZmF1bHRPcHRpb25zO1xuZXhwb3J0cy50b3RwRXBvY2hBdmFpbGFibGUgPSB0b3RwRXBvY2hBdmFpbGFibGU7XG5leHBvcnRzLnRvdHBLZXl1cmkgPSB0b3RwS2V5dXJpO1xuZXhwb3J0cy50b3RwT3B0aW9ucyA9IHRvdHBPcHRpb25zO1xuZXhwb3J0cy50b3RwT3B0aW9uc1ZhbGlkYXRvciA9IHRvdHBPcHRpb25zVmFsaWRhdG9yO1xuZXhwb3J0cy50b3RwUGFkU2VjcmV0ID0gdG90cFBhZFNlY3JldDtcbmV4cG9ydHMudG90cFRpbWVSZW1haW5pbmcgPSB0b3RwVGltZVJlbWFpbmluZztcbmV4cG9ydHMudG90cFRpbWVVc2VkID0gdG90cFRpbWVVc2VkO1xuZXhwb3J0cy50b3RwVG9rZW4gPSB0b3RwVG9rZW47XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@otplib+core@12.0.1/node_modules/@otplib/core/index.js\n");

/***/ })

};
;